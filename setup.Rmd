---
title: "Untitled"
author: "Tim Hill"
date: "8 December 2016"
output: html_document
---

```{r}

library(nzelect)
library(leaflet)
library(ggmap)
library(rgdal)
library(rgeos)
library(tidyr)
library(raster)
library(dplyr)
library(ggplot2)
library(GGally)
library(leaflet.extras)
library(geosphere)

```

```{r, cache = T}
## Load electoral boundary data
electorates <- readOGR("/Users/Tim/Dropbox/R_files/data/kx-general-electoral-district-boundaries-2014-SHP", layer = "general-electoral-district-boundaries-2014")

##Subset the electoral boundary data to only those in the Christchurch area
chchlist <- c("Waimakariri","Selwyn","Ilam","Christchurch Central","Wigram","Port Hills", "Christchurch East")
chchelectorates <- electorates[electorates$name %in% chchlist,]

##Convert electorate boundary data to suitable datum
chchelectorates <- spTransform(chchelectorates, CRS("+proj=longlat +datum=WGS84 +no_defs"))

rm(chchlist,electorates)
plot(chchelectorates)

```

```{r, cache = T}
# Find the 2013 meshblocks for the chosen electorates
##First, load full NZ meshblock data
fullmeshblocks <- readOGR("/Users/Tim/Dropbox/R_files/data/2013censusmeshblocks", layer = "MB2013_GV_Full")

##use projection from stackoverflow.com/questions/33045388/projecting-my-shapefile-data-on-leaflet-map-using-r
fullmeshblocks <- spTransform(fullmeshblocks, CRS("+proj=longlat +datum=WGS84 +no_defs"))

```

```{r}

##Use raster package to select only those meshblocks in the Christchurch electorates
cantymeshblocks <- raster::intersect(chchelectorates, fullmeshblocks)
rm(fullmeshblocks)
plot(cantymeshblocks)

```

```{r}
# get voting place data
votes <- GE2014
locations <- Locations2014

##
electorates2 <- c("Christchurch Central 4", "Christchurch East 5","Ilam 18","Port Hills 41","Waimakariri 57","Selwyn 48", "Wigram 64")

#votingplaces <- votes %>% select(VotingPlace) %>% distinct() %>% droplevels()

#votes <- votes %>% filter((Electorate %in% electorates2) & VotingType == "Party")

#parties <- votes %>% select(Party) %>% distinct() %>% .[,1]
#print(parties)


votes <- votes %>% filter((Electorate %in% electorates2) & VotingType == "Party") %>%
  group_by(VotingPlace) %>%
  mutate(propNat = sum(Votes[Party == "National Party"]) / sum(Votes), 
         propLab = sum(Votes[Party == "Labour Party"]) / sum(Votes), 
         propGrn = sum(Votes[Party == "Green Party"]) / sum(Votes), 
         propMaori = sum(Votes[Party == "Maori Party"]) / sum(Votes), 
         propCannabis = sum(Votes[Party == "Aotearoa Legalise Cannabis Party"]) / sum(Votes), 
         prop1080 = sum(Votes[Party == "Ban1080"]) / sum(Votes), 
         propCon = sum(Votes[Party == "Conservative"]) / sum(Votes), 
         propDSC = sum(Votes[Party == "Democrats for Social Credit"]) / sum(Votes), 
         propFocus = sum(Votes[Party == "Focus New Zealand"]) / sum(Votes), 
         propIntMana = sum(Votes[Party == "Internet Mana"]) / sum(Votes), 
         propNZF = sum(Votes[Party == "New Zealand First Party"]) / sum(Votes), 
         propIndep = sum(Votes[Party == "NZ Independent Coalition"]) / sum(Votes), 
         propCivilian = sum(Votes[Party == "The Civilian Party"]) / sum(Votes), 
         propUnited = sum(Votes[Party == "United Future"]) / sum(Votes), 
         propInformalVotes = sum(Votes[Party == "Informal Party Votes"]) / sum(Votes)) %>%
  ungroup() %>%
  select(1:2,8:22) %>%
  #na.omit() %>%
  distinct() %>% left_join(locations, by = "VotingPlace")

##Convert votes df to spatialPolygons data type
votes <- as.data.frame(na.omit(votes))
coordinates(votes) <- ~WGS84Longitude+WGS84Latitude
proj4string(votes) <- CRS("+proj=longlat +datum=WGS84 +no_defs")

rm(electorates2)

plot(votes)

```




```{r meshblockCentroids}

##Find centroid of each meshblock
meshcentroids <- gCentroid(cantymeshblocks, byid = T)
plot(meshcentroids)

##Calculate distance matrix for meshblocks and voting places
distance <- distm(meshcentroids, votes)
  
closest <- vector()
  
for(i in 1:nrow(distance)) {
  closest[i] <- votes$VotingPlaceID[base::which.min(distance[i,])]
}

cantymeshblocks$VotingPlaceID <- closest

##Join data
cantymeshblocks@data <- merge(cantymeshblocks@data, votes@data, by = "VotingPlaceID", all.x = T)

```




```{r}

chchloc <- geocode("Christchurch, NZ")

m1placepopup <- paste0("<b>Address: </b>",votes$VotingPlace,"<br>",
                       "<b>Electorate: </b>", votes$ElectorateName, "<br>",
                       "<b>Location Code: </b>", votes$VotingPlaceID)

m1meshpopup <- paste0("<b>Meshblock code: </b>",cantymeshblocks$MB2013,"<br>",
                      "<b>Area: </b>",cantymeshblocks$AU2013_NAM,"<br>",
                      "<b>Voting Location: </b>",cantymeshblocks$VotingPlace)

pal1 <- colorNumeric(palette = "Blues", domain = cantymeshblocks$propNat)


m1 <- leaflet() %>% setView(lat = chchloc[2], lng = chchloc[1], zoom = 10) %>% 
  addTiles() %>%
  addProviderTiles("OpenStreetMap.HOT") %>%
  addPolygons(data = chchelectorates, fillOpacity = 0, color = "blue", weight = 3) %>% 
  addPolygons(data = cantymeshblocks, stroke = TRUE, color = "blue", weight = 0.5, opacity = 1, 
              fillColor = ~pal1(propNat), fillOpacity = 0.5, popup = m1meshpopup) %>%
  addMarkers(data = na.omit(votes), 
            clusterOptions = markerClusterOptions(), 
             popup = m1placepopup)

m1
```

